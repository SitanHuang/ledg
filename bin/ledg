#!/usr/bin/env node
function fzy_query_account(q, accounts=Object.keys(data.accounts)) {
  if (q[0] == '!')
    return accounts.filter(a => a == q.substring(1)).sort();
  return accounts.filter(a => fzy_compare(q, a)).sort();
}

function fzy_compare(q, acc) {
  q = ("^[^.]*" + q
    .replace(/\*/g, '␞')
    .replace(/\./g, '[^.]*\\.[^.]*')
    .replace(/([a-z])/gi, '[^.]*$1[^.]*') + '[^.]*$')
    .replace(/\[\^\.\]\*\[\^\.\]\*/g, '[^.]*')
    .replace(/\[\^\.\]\*\.\*/g, '.*')
    .replace(/␞/g, '.*?');

  let rgx = new RegExp(q, 'i');
  return !!acc.match(rgx);
}

function isArgAccount(v) {
  let len = v.length;
  while (len--) {
    switch (v[len]) {
      case ".":
      case "*":
      case "$":
      case "!":
        return true;
    }
  }
  return false;
}
var data = null;

function data_init_data() {
  data = {
    accounts: {},
    books: {}, // { 2019: [ ... ], 2020: [ ... ], ...  }
    booksOpened: {}
  };
  return data;
}

data_init_data();

async function data_open_books(books) {
  for (let y of books) {
    if (data.booksOpened[y] >= DATA_BOOK_OPENED) continue;
    await fs_read_book(y);
    data.booksOpened[y] = Math.max(DATA_BOOK_OPENED, data.booksOpened[y]); // fs_read_book could set it to dirty
  }
}

function data_books_required(d1, d2) {
  d1 = new Date(d1).getFullYear();
  if (!d2) return d1;
  d2 = new Date(d2).getFullYear();
  let yr = [];
  for (let i=d1; i<=d2; i++) {
    yr.push(i);
  }
  return yr;
}

async function data_remove_entry(entry) {
  let y = new Date(entry.time * 1000).getFullYear();
  await data_open_books([y]);
  data.books[y] = data.books[y].filter(x => x.uuid != entry.uuid);
  data.booksOpened[y] = DATA_BOOK_DIRTY;
}

async function data_remove_entry(entry) {
  
}

// async function data_edit_entry(entry) {
//   let range = await fs_get_data_range();
//   await data_open_books(range);
//   for (let y : range) {
//     
//   }
// }

async function data_push_entry(entry) {
  let y = new Date(entry.time * 1000).getFullYear();
  await data_open_books([y]);
  data.books[y] = data.books[y] || [];
  data.books[y].push(entry);
  for (let t of entry.transfers) {
    let acc = t[1];
    data.accounts[acc] = 1;
  }
  data.booksOpened[y] = DATA_BOOK_DIRTY;
}

async function data_push_entries(entries) {
  let min, max;
  min = max = new Date().getTime() / 1000;
  for (let e of entries) {
    min = Math.min(min, e.time);
    max = Math.max(max, e.time);
  }
  await data_open_books(data_books_required(min * 1000, max * 1000));
  for (let e of entries)
    await data_push_entry(e);
}

async function data_iterate_books(books, callback, afterOpenCallback) {
  await data_open_books(books);
  if (afterOpenCallback) await afterOpenCallback();
  for (let b of books) {
    let book = data.books[b];
    if (await callback(book) == DATA_CALLBACK_STOP) break;
  }
}

/*
 * =====================================
 * Constants
 * =====================================
 */
DATA_BOOK_OPENED = 1;
DATA_BOOK_DIRTY = 2;

DATA_CALLBACK_STOP = 999;

/*
 * ======================================
 * Runtime infos
 * ======================================
 */
var data_acc_imb = 'Imbalance';
/*
 * desc = description of entry
 * transfers = [[desc, acc, amnt], ...]
 *  - amnt should be primative, rounded to 2 dec
 * opts = { ... }
 * balanced = pass true if already balanced
 */
function entry_create(desc, transfers, opts, balanced) {
  let e = {
    uuid: nanoid(8),
    time: Math.floor(new Date().getTime() / 1000),
    description: desc,
    transfers: transfers
  };

  Object.assign(e, opts);

  if (!balanced) {
    entry_balance(e);
  }
  return e;
}

function entry_balance(e) {
  let balance = entry_check_balance(e.transfers);
  if (balance) {
    if (e.transfers[e.transfers.length - 1][2] == 0) // last entry auto balance
      e.transfers[e.transfers.length - 1][2] = balance;
    else
      e.transfers.push(['', data_acc_imb, balance]);
  }
}

function entry_datestr(entry) {
  let date = new Date(entry.time * 1000);
  return date.toISOString().split('T')[0];
}

function entry_check_balance(transfers) {
  let balance = new Big(0);
  for (let t of transfers) {
    balance = balance.add(t[2]);
  }
  return -balance.toNumber();
}
var Big;
(function (GLOBAL) {
  //var Big,
  var


/************************************** EDITABLE DEFAULTS *****************************************/


    // The default values below must be integers within the stated ranges.

    /*
     * The maximum number of decimal places (DP) of the results of operations involving division:
     * div and sqrt, and pow with negative exponents.
     */
    DP = 4,            // 0 to MAX_DP

    /*
     * The rounding mode (RM) used when rounding to the above decimal places.
     *
     *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
     *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
     *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
     *  3  Away from zero.                                  (ROUND_UP)
     */
    RM = 1,             // 0, 1, 2 or 3

    // The maximum value of DP and Big.DP.
    MAX_DP = 1E6,       // 0 to 1000000

    // The maximum magnitude of the exponent argument to the pow method.
    MAX_POWER = 1E6,    // 1 to 1000000

    /*
     * The negative exponent (NE) at and beneath which toString returns exponential notation.
     * (JavaScript numbers: -7)
     * -1000000 is the minimum recommended exponent value of a Big.
     */
    NE = -7,            // 0 to -1000000

    /*
     * The positive exponent (PE) at and above which toString returns exponential notation.
     * (JavaScript numbers: 21)
     * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.
     */
    PE = 21,            // 0 to 1000000

    /*
     * When true, an error will be thrown if a primitive number is passed to the Big constructor,
     * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a
     * primitive number without a loss of precision.
     */
    STRICT = false,     // true or false


/**************************************************************************************************/


    // Error messages.
    NAME = '[big.js] ',
    INVALID = NAME + 'Invalid ',
    INVALID_DP = INVALID + 'decimal places',
    INVALID_RM = INVALID + 'rounding mode',
    DIV_BY_ZERO = NAME + 'Division by zero',

    // The shared prototype object.
    P = {},
    UNDEFINED = void 0,
    NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;


  /*
   * Create and return a Big constructor.
   */
  function _Big_() {

    /*
     * The Big constructor and exported function.
     * Create and return a new instance of a Big number object.
     *
     * n {number|string|Big} A numeric value.
     */
    function Big(n) {
      var x = this;

      // Enable constructor usage without new.
      if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

      // Duplicate.
      if (n instanceof Big) {
        x.s = n.s;
        x.e = n.e;
        x.c = n.c.slice();
      } else {
        if (typeof n !== 'string') {
          if (Big.strict === true) {
            throw TypeError(INVALID + 'number');
          }

          // Minus zero?
          n = n === 0 && 1 / n < 0 ? '-0' : String(n);
        }

        parse(x, n);
      }

      // Retain a reference to this Big constructor.
      // Shadow Big.prototype.constructor which points to Object.
      x.constructor = Big;
    }

    Big.prototype = P;
    Big.DP = DP;
    Big.RM = RM;
    Big.NE = NE;
    Big.PE = PE;
    Big.strict = STRICT;

    return Big;
  }


  /*
   * Parse the number or string value passed to a Big constructor.
   *
   * x {Big} A Big number instance.
   * n {number|string} A numeric value.
   */
  function parse(x, n) {
    var e, i, nl;

    if (!NUMERIC.test(n)) {
      throw Error(INVALID + 'number');
    }

    // Determine sign.
    x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

    // Decimal point?
    if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

    // Exponential form?
    if ((i = n.search(/e/i)) > 0) {

      // Determine exponent.
      if (e < 0) e = i;
      e += +n.slice(i + 1);
      n = n.substring(0, i);
    } else if (e < 0) {

      // Integer.
      e = n.length;
    }

    nl = n.length;

    // Determine leading zeros.
    for (i = 0; i < nl && n.charAt(i) == '0';) ++i;

    if (i == nl) {

      // Zero.
      x.c = [x.e = 0];
    } else {

      // Determine trailing zeros.
      for (; nl > 0 && n.charAt(--nl) == '0';);
      x.e = e - i - 1;
      x.c = [];

      // Convert string to array of digits without leading/trailing zeros.
      for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
    }

    return x;
  }


  /*
   * Round Big x to a maximum of sd significant digits using rounding mode rm.
   *
   * x {Big} The Big to round.
   * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
   * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   * [more] {boolean} Whether the result of division was truncated.
   */
  function round(x, sd, rm, more) {
    var xc = x.c;

    if (rm === UNDEFINED) rm = Big.RM;
    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
      throw Error(INVALID_RM);
    }

    if (sd < 1) {
      more =
        rm === 3 && (more || !!xc[0]) || sd === 0 && (
        rm === 1 && xc[0] >= 5 ||
        rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))
      );

      xc.length = 1;

      if (more) {

        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
        x.e = x.e - sd + 1;
        xc[0] = 1;
      } else {

        // Zero.
        xc[0] = x.e = 0;
      }
    } else if (sd < xc.length) {

      // xc[sd] is the digit after the digit that may be rounded up.
      more =
        rm === 1 && xc[sd] >= 5 ||
        rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&
          (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||
        rm === 3 && (more || !!xc[0]);

      // Remove any digits after the required precision.
      xc.length = sd--;

      // Round up?
      if (more) {

        // Rounding up may mean the previous digit has to be rounded up.
        for (; ++xc[sd] > 9;) {
          xc[sd] = 0;
          if (!sd--) {
            ++x.e;
            xc.unshift(1);
          }
        }
      }

      // Remove trailing zeros.
      for (sd = xc.length; !xc[--sd];) xc.pop();
    }

    return x;
  }


  /*
   * Return a string representing the value of Big x in normal or exponential notation.
   * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
   */
  function stringify(x, doExponential, isNonzero) {
    var e = x.e,
      s = x.c.join(''),
      n = s.length;

    // Exponential notation?
    if (doExponential) {
      s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

    // Normal notation.
    } else if (e < 0) {
      for (; ++e;) s = '0' + s;
      s = '0.' + s;
    } else if (e > 0) {
      if (++e > n) {
        for (e -= n; e--;) s += '0';
      } else if (e < n) {
        s = s.slice(0, e) + '.' + s.slice(e);
      }
    } else if (n > 1) {
      s = s.charAt(0) + '.' + s.slice(1);
    }

    return x.s < 0 && isNonzero ? '-' + s : s;
  }


  // Prototype/instance methods


  /*
   * Return a new Big whose value is the absolute value of this Big.
   */
  P.abs = function () {
    var x = new this.constructor(this);
    x.s = 1;
    return x;
  };


  /*
   * Return 1 if the value of this Big is greater than the value of Big y,
   *       -1 if the value of this Big is less than the value of Big y, or
   *        0 if they have the same value.
   */
  P.cmp = function (y) {
    var isneg,
      x = this,
      xc = x.c,
      yc = (y = new x.constructor(y)).c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either zero?
    if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;

    isneg = i < 0;

    // Compare exponents.
    if (k != l) return k > l ^ isneg ? 1 : -1;

    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = -1; ++i < j;) {
      if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
    }

    // Compare lengths.
    return k == l ? 0 : k > l ^ isneg ? 1 : -1;
  };


  /*
   * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
   * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
   */
  P.div = function (y) {
    var x = this,
      Big = x.constructor,
      a = x.c,                  // dividend
      b = (y = new Big(y)).c,   // divisor
      k = x.s == y.s ? 1 : -1,
      dp = Big.DP;

    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }

    // Divisor is zero?
    if (!b[0]) {
      throw Error(DIV_BY_ZERO);
    }

    // Dividend is 0? Return +-0.
    if (!a[0]) {
      y.s = k;
      y.c = [y.e = 0];
      return y;
    }

    var bl, bt, n, cmp, ri,
      bz = b.slice(),
      ai = bl = b.length,
      al = a.length,
      r = a.slice(0, bl),   // remainder
      rl = r.length,
      q = y,                // quotient
      qc = q.c = [],
      qi = 0,
      p = dp + (q.e = x.e - y.e) + 1;    // precision of the result

    q.s = k;
    k = p < 0 ? 0 : p;

    // Create version of divisor with leading zero.
    bz.unshift(0);

    // Add zeros to make remainder as long as divisor.
    for (; rl++ < bl;) r.push(0);

    do {

      // n is how many times the divisor goes into current remainder.
      for (n = 0; n < 10; n++) {

        // Compare divisor and remainder.
        if (bl != (rl = r.length)) {
          cmp = bl > rl ? 1 : -1;
        } else {
          for (ri = -1, cmp = 0; ++ri < bl;) {
            if (b[ri] != r[ri]) {
              cmp = b[ri] > r[ri] ? 1 : -1;
              break;
            }
          }
        }

        // If divisor < remainder, subtract divisor from remainder.
        if (cmp < 0) {

          // Remainder can't be more than 1 digit longer than divisor.
          // Equalise lengths using divisor with extra leading zero?
          for (bt = rl == bl ? b : bz; rl;) {
            if (r[--rl] < bt[rl]) {
              ri = rl;
              for (; ri && !r[--ri];) r[ri] = 9;
              --r[ri];
              r[rl] += 10;
            }
            r[rl] -= bt[rl];
          }

          for (; !r[0];) r.shift();
        } else {
          break;
        }
      }

      // Add the digit n to the result array.
      qc[qi++] = cmp ? n : ++n;

      // Update the remainder.
      if (r[0] && cmp) r[rl] = a[ai] || 0;
      else r = [a[ai]];

    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

    // Leading zero? Do not remove if result is simply zero (qi == 1).
    if (!qc[0] && qi != 1) {

      // There can't be more than one zero.
      qc.shift();
      q.e--;
      p--;
    }

    // Round?
    if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);

    return q;
  };


  /*
   * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
   */
  P.eq = function (y) {
    return this.cmp(y) === 0;
  };


  /*
   * Return true if the value of this Big is greater than the value of Big y, otherwise return
   * false.
   */
  P.gt = function (y) {
    return this.cmp(y) > 0;
  };


  /*
   * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
   * return false.
   */
  P.gte = function (y) {
    return this.cmp(y) > -1;
  };


  /*
   * Return true if the value of this Big is less than the value of Big y, otherwise return false.
   */
  P.lt = function (y) {
    return this.cmp(y) < 0;
  };


  /*
   * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
   * return false.
   */
  P.lte = function (y) {
    return this.cmp(y) < 1;
  };


  /*
   * Return a new Big whose value is the value of this Big minus the value of Big y.
   */
  P.minus = P.sub = function (y) {
    var i, j, t, xlty,
      x = this,
      Big = x.constructor,
      a = x.s,
      b = (y = new Big(y)).s;

    // Signs differ?
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }

    var xc = x.c.slice(),
      xe = x.e,
      yc = y.c,
      ye = y.e;

    // Either zero?
    if (!xc[0] || !yc[0]) {
      if (yc[0]) {
        y.s = -b;
      } else if (xc[0]) {
        y = new Big(x);
      } else {
        y.s = 1;
      }
      return y;
    }

    // Determine which is the bigger number. Prepend zeros to equalise exponents.
    if (a = xe - ye) {

      if (xlty = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }

      t.reverse();
      for (b = a; b--;) t.push(0);
      t.reverse();
    } else {

      // Exponents equal. Check digit by digit.
      j = ((xlty = xc.length < yc.length) ? xc : yc).length;

      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xlty = xc[b] < yc[b];
          break;
        }
      }
    }

    // x < y? Point xc to the array of the bigger number.
    if (xlty) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }

    /*
     * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
     * needs to start at yc.length.
     */
    if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

    // Subtract yc from xc.
    for (b = i; j > a;) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i];) xc[i] = 9;
        --xc[i];
        xc[j] += 10;
      }

      xc[j] -= yc[j];
    }

    // Remove trailing zeros.
    for (; xc[--b] === 0;) xc.pop();

    // Remove leading zeros and adjust exponent accordingly.
    for (; xc[0] === 0;) {
      xc.shift();
      --ye;
    }

    if (!xc[0]) {

      // n - n = +0
      y.s = 1;

      // Result must be zero.
      xc = [ye = 0];
    }

    y.c = xc;
    y.e = ye;

    return y;
  };


  /*
   * Return a new Big whose value is the value of this Big modulo the value of Big y.
   */
  P.mod = function (y) {
    var ygtx,
      x = this,
      Big = x.constructor,
      a = x.s,
      b = (y = new Big(y)).s;

    if (!y.c[0]) {
      throw Error(DIV_BY_ZERO);
    }

    x.s = y.s = 1;
    ygtx = y.cmp(x) == 1;
    x.s = a;
    y.s = b;

    if (ygtx) return new Big(x);

    a = Big.DP;
    b = Big.RM;
    Big.DP = Big.RM = 0;
    x = x.div(y);
    Big.DP = a;
    Big.RM = b;

    return this.minus(x.times(y));
  };


  /*
   * Return a new Big whose value is the value of this Big plus the value of Big y.
   */
  P.plus = P.add = function (y) {
    var e, k, t,
      x = this,
      Big = x.constructor;

    y = new Big(y);

    // Signs differ?
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }

    var xe = x.e,
      xc = x.c,
      ye = y.e,
      yc = y.c;

    // Either zero?
    if (!xc[0] || !yc[0]) {
      if (!yc[0]) {
        if (xc[0]) {
          y = new Big(x);
        } else {
          y.s = x.s;
        }
      }
      return y;
    }

    xc = xc.slice();

    // Prepend zeros to equalise exponents.
    // Note: reverse faster than unshifts.
    if (e = xe - ye) {
      if (e > 0) {
        ye = xe;
        t = yc;
      } else {
        e = -e;
        t = xc;
      }

      t.reverse();
      for (; e--;) t.push(0);
      t.reverse();
    }

    // Point xc to the longer array.
    if (xc.length - yc.length < 0) {
      t = yc;
      yc = xc;
      xc = t;
    }

    e = yc.length;

    // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
    for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;

    // No need to check for zero, as +x + +y != 0 && -x + -y != 0

    if (k) {
      xc.unshift(k);
      ++ye;
    }

    // Remove trailing zeros.
    for (e = xc.length; xc[--e] === 0;) xc.pop();

    y.c = xc;
    y.e = ye;

    return y;
  };


  /*
   * Return a Big whose value is the value of this Big raised to the power n.
   * If n is negative, round to a maximum of Big.DP decimal places using rounding
   * mode Big.RM.
   *
   * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
   */
  P.pow = function (n) {
    var x = this,
      one = new x.constructor('1'),
      y = one,
      isneg = n < 0;

    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
      throw Error(INVALID + 'exponent');
    }

    if (isneg) n = -n;

    for (;;) {
      if (n & 1) y = y.times(x);
      n >>= 1;
      if (!n) break;
      x = x.times(x);
    }

    return isneg ? one.div(y) : y;
  };


  /*
   * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
   * significant digits using rounding mode rm, or Big.RM if rm is not specified.
   *
   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */
  P.prec = function (sd, rm) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + 'precision');
    }
    return round(new this.constructor(this), sd, rm);
  };


  /*
   * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
   * using rounding mode rm, or Big.RM if rm is not specified.
   * If dp is negative, round to an integer which is a multiple of 10**-dp.
   * If dp is not specified, round to 0 decimal places.
   *
   * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */
  P.round = function (dp, rm) {
    if (dp === UNDEFINED) dp = 0;
    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    return round(new this.constructor(this), dp + this.e + 1, rm);
  };


  /*
   * Return a new Big whose value is the square root of the value of this Big, rounded, if
   * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
   */
  P.sqrt = function () {
    var r, c, t,
      x = this,
      Big = x.constructor,
      s = x.s,
      e = x.e,
      half = new Big('0.5');

    // Zero?
    if (!x.c[0]) return new Big(x);

    // Negative?
    if (s < 0) {
      throw Error(NAME + 'No square root');
    }

    // Estimate.
    s = Math.sqrt(x + '');

    // Math.sqrt underflow/overflow?
    // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
    if (s === 0 || s === 1 / 0) {
      c = x.c.join('');
      if (!(c.length + e & 1)) c += '0';
      s = Math.sqrt(c);
      e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
      r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
    } else {
      r = new Big(s + '');
    }

    e = r.e + (Big.DP += 4);

    // Newton-Raphson iteration.
    do {
      t = r;
      r = half.times(t.plus(x.div(t)));
    } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));

    return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);
  };


  /*
   * Return a new Big whose value is the value of this Big times the value of Big y.
   */
  P.times = P.mul = function (y) {
    var c,
      x = this,
      Big = x.constructor,
      xc = x.c,
      yc = (y = new Big(y)).c,
      a = xc.length,
      b = yc.length,
      i = x.e,
      j = y.e;

    // Determine sign of result.
    y.s = x.s == y.s ? 1 : -1;

    // Return signed 0 if either 0.
    if (!xc[0] || !yc[0]) {
      y.c = [y.e = 0];
      return y;
    }

    // Initialise exponent of result as x.e + y.e.
    y.e = i + j;

    // If array xc has fewer digits than yc, swap xc and yc, and lengths.
    if (a < b) {
      c = xc;
      xc = yc;
      yc = c;
      j = a;
      a = b;
      b = j;
    }

    // Initialise coefficient array of result with zeros.
    for (c = new Array(j = a + b); j--;) c[j] = 0;

    // Multiply.

    // i is initially xc.length.
    for (i = b; i--;) {
      b = 0;

      // a is yc.length.
      for (j = a + i; j > i;) {

        // Current sum of products at this digit position, plus carry.
        b = c[j] + yc[i] * xc[j - i - 1] + b;
        c[j--] = b % 10;

        // carry
        b = b / 10 | 0;
      }

      c[j] = b;
    }

    // Increment result exponent if there is a final carry, otherwise remove leading zero.
    if (b) ++y.e;
    else c.shift();

    // Remove trailing zeros.
    for (i = c.length; !c[--i];) c.pop();
    y.c = c;

    return y;
  };


  /*
   * Return a string representing the value of this Big in exponential notation rounded to dp fixed
   * decimal places using rounding mode rm, or Big.RM if rm is not specified.
   *
   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */
  P.toExponential = function (dp, rm) {
    var x = this,
      n = x.c[0];

    if (dp !== UNDEFINED) {
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      x = round(new x.constructor(x), ++dp, rm);
      for (; x.c.length < dp;) x.c.push(0);
    }

    return stringify(x, true, !!n);
  };


  /*
   * Return a string representing the value of this Big in normal notation rounded to dp fixed
   * decimal places using rounding mode rm, or Big.RM if rm is not specified.
   *
   * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   *
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
   */
  P.toFixed = function (dp, rm) {
    var x = this,
      n = x.c[0];

    if (dp !== UNDEFINED) {
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      x = round(new x.constructor(x), dp + x.e + 1, rm);

      // x.e may have changed if the value is rounded up.
      for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);
    }

    return stringify(x, false, !!n);
  };


  /*
   * Return a string representing the value of this Big.
   * Return exponential notation if this Big has a positive exponent equal to or greater than
   * Big.PE, or a negative exponent equal to or less than Big.NE.
   * Omit the sign for negative zero.
   */
  P.toJSON = P.toString = function () {
    var x = this,
      Big = x.constructor;
    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);
  };


  /*
   * Return the value of this Big as a primitve number.
   */
  P.toNumber = function () {
    var n = Number(stringify(this, true, true));
    if (this.constructor.strict === true && !this.eq(n.toString())) {
      throw Error(NAME + 'Imprecise conversion');
    }
    return n;
  };


  /*
   * Return a string representing the value of this Big rounded to sd significant digits using
   * rounding mode rm, or Big.RM if rm is not specified.
   * Use exponential notation if sd is less than the number of digits necessary to represent
   * the integer part of the value in normal notation.
   *
   * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
   * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
   */
  P.toPrecision = function (sd, rm) {
    var x = this,
      Big = x.constructor,
      n = x.c[0];

    if (sd !== UNDEFINED) {
      if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
        throw Error(INVALID + 'precision');
      }
      x = round(new Big(x), sd, rm);
      for (; x.c.length < sd;) x.c.push(0);
    }

    return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);
  };


  /*
   * Return a string representing the value of this Big.
   * Return exponential notation if this Big has a positive exponent equal to or greater than
   * Big.PE, or a negative exponent equal to or less than Big.NE.
   * Include the sign for negative zero.
   */
  P.valueOf = function () {
    var x = this,
      Big = x.constructor;
    if (Big.strict === true) {
      throw Error(NAME + 'valueOf disallowed');
    }
    return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);
  };


  // Export


  Big = _Big_();

  Big['default'] = Big.Big = Big;

//   AMD.
//   if (typeof define === 'function' && define.amd) {
//     define(function () { return Big; });
// 
//   Node and other CommonJS-like environments that support module.exports.
//   } else if (typeof module !== 'undefined' && module.exports) {
//     module.exports = Big;
// 
//   Browser.
//   } else {
//     GLOBAL.Big = Big;
//   }
})(this);
 
/*!
 * accounting.js v0.4.2
 * Copyright 2014 Open Exchange Rates
 *
 * Freely distributable under the MIT license.
 * Portions of accounting.js are inspired or borrowed from underscore.js
 *
 * Full details and documentation:
 * http://openexchangerates.github.io/accounting.js/
 */
var accounting;
(function(root, undefined) {

    /* --- Setup --- */

    // Create the local library object, to be exported or referenced globally later
    var lib = {};

    // Current version
    lib.version = '0.4.2';


    /* --- Exposed settings --- */

    // The library's settings configuration object. Contains default parameters for
    // currency and number formatting
    lib.settings = {
        currency: {
            symbol: "", // default currency symbol is '$'
            format: "%s%v", // controls output: %s = symbol, %v = value (can be object, see docs)
            decimal: ".", // decimal point separator
            thousand: ",", // thousands separator
            precision: 2, // decimal places
            grouping: 3 // digit grouping (not implemented yet)
        },
        number: {
            precision: 0, // default precision on numbers is 0
            grouping: 3, // digit grouping (not implemented yet)
            thousand: ",",
            decimal: "."
        }
    };


    /* --- Internal Helper Methods --- */

    // Store reference to possibly-available ECMAScript 5 methods for later
    var nativeMap = Array.prototype.map,
        nativeIsArray = Array.isArray,
        toString = Object.prototype.toString;

    /**
     * Tests whether supplied parameter is a string
     * from underscore.js
     */
    function isString(obj) {
        return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));
    }

    /**
     * Tests whether supplied parameter is an array
     * from underscore.js, delegates to ECMA5's native Array.isArray
     */
    function isArray(obj) {
        return nativeIsArray ? nativeIsArray(obj) : toString.call(obj) === '[object Array]';
    }

    /**
     * Tests whether supplied parameter is a true object
     */
    function isObject(obj) {
        return obj && toString.call(obj) === '[object Object]';
    }

    /**
     * Extends an object with a defaults object, similar to underscore's _.defaults
     *
     * Used for abstracting parameter handling from API methods
     */
    function defaults(object, defs) {
        var key;
        object = object || {};
        defs = defs || {};
        // Iterate over object non-prototype properties:
        for (key in defs) {
            if (defs.hasOwnProperty(key)) {
                // Replace values with defaults only if undefined (allow empty/zero values):
                if (object[key] == null) object[key] = defs[key];
            }
        }
        return object;
    }

    /**
     * Implementation of `Array.map()` for iteration loops
     *
     * Returns a new Array as a result of calling `iterator` on each array value.
     * Defers to native Array.map if available
     */
    function map(obj, iterator, context) {
        var results = [],
            i, j;

        if (!obj) return results;

        // Use native .map method if it exists:
        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);

        // Fallback for native .map:
        for (i = 0, j = obj.length; i < j; i++) {
            results[i] = iterator.call(context, obj[i], i, obj);
        }
        return results;
    }

    /**
     * Check and normalise the value of precision (must be positive integer)
     */
    function checkPrecision(val, base) {
        val = Math.round(Math.abs(val));
        return isNaN(val) ? base : val;
    }


    /**
     * Parses a format string or object and returns format obj for use in rendering
     *
     * `format` is either a string with the default (positive) format, or object
     * containing `pos` (required), `neg` and `zero` values (or a function returning
     * either a string or object)
     *
     * Either string or format.pos must contain "%v" (value) to be valid
     */
    function checkCurrencyFormat(format) {
        var defaults = lib.settings.currency.format;

        // Allow function as format parameter (should return string or object):
        if (typeof format === "function") format = format();

        // Format can be a string, in which case `value` ("%v") must be present:
        if (isString(format) && format.match("%v")) {

            // Create and return positive, negative and zero formats:
            return {
                pos: format,
                neg: format.replace("-", "").replace("%v", "-%v"),
                zero: format
            };

            // If no format, or object is missing valid positive value, use defaults:
        } else if (!format || !format.pos || !format.pos.match("%v")) {

            // If defaults is a string, casts it to an object for faster checking next time:
            return (!isString(defaults)) ? defaults : lib.settings.currency.format = {
                pos: defaults,
                neg: defaults.replace("%v", "-%v"),
                zero: defaults
            };

        }
        // Otherwise, assume format was fine:
        return format;
    }


    /* --- API Methods --- */

    /**
     * Takes a string/array of strings, removes all formatting/cruft and returns the raw float value
     * Alias: `accounting.parse(string)`
     *
     * Decimal must be included in the regular expression to match floats (defaults to
     * accounting.settings.number.decimal), so if the number uses a non-standard decimal 
     * separator, provide it as the second argument.
     *
     * Also matches bracketed negatives (eg. "$ (1.99)" => -1.99)
     *
     * Doesn't throw any errors (`NaN`s become 0) but this may change in future
     */
    var unformat = lib.unformat = lib.parse = function(value, decimal) {
        // Recursively unformat arrays:
        if (isArray(value)) {
            return map(value, function(val) {
                return unformat(val, decimal);
            });
        }

        // Fails silently (need decent errors):
        value = value || 0;

        // Return the value as-is if it's already a number:
        if (typeof value === "number") return value;

        // Default decimal point comes from settings, but could be set to eg. "," in opts:
        decimal = decimal || lib.settings.number.decimal;

        // Build regex to strip out everything except digits, decimal point and minus sign:
        var regex = new RegExp("[^0-9-" + decimal + "]", ["g"]),
            unformatted = parseFloat(
            ("" + value)
                .replace(/\((?=\d+)(.*)\)/, "-$1") // replace bracketed values with negatives
            .replace(regex, '') // strip out any cruft
            .replace(decimal, '.') // make sure decimal point is standard
            );

        // This will fail silently which may cause trouble, let's wait and see:
        return !isNaN(unformatted) ? unformatted : 0;
    };


    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === "0.61") that present
     * problems for accounting- and finance-related software.
     */
    var toFixed = lib.toFixed = function(value, precision) {
        precision = checkPrecision(precision, lib.settings.number.precision);

        var exponentialForm = Number(lib.unformat(value) + 'e' + precision);
        var rounded = Math.round(exponentialForm);
        var finalResult = Number(rounded + 'e-' + precision).toFixed(precision);
        return finalResult;
    };


    /**
     * Format a number, with comma-separated thousands and custom precision/decimal places
     * Alias: `accounting.format()`
     *
     * Localise by overriding the precision and thousand / decimal separators
     * 2nd parameter `precision` can be an object matching `settings.number`
     */
    var formatNumber = lib.formatNumber = lib.format = function(number, precision, thousand, decimal) {
        // Resursively format arrays:
        if (isArray(number)) {
            return map(number, function(val) {
                return formatNumber(val, precision, thousand, decimal);
            });
        }

        // Clean up number:
        number = unformat(number);

        // Build options object from second param (if object) or all params, extending defaults:
        var opts = defaults(
        (isObject(precision) ? precision : {
            precision: precision,
            thousand: thousand,
            decimal: decimal
        }),
        lib.settings.number),

            // Clean up precision
            usePrecision = checkPrecision(opts.precision),

            // Do some calc:
            negative = number < 0 ? "-" : "",
            base = parseInt(toFixed(Math.abs(number || 0), usePrecision), 10) + "",
            mod = base.length > 3 ? base.length % 3 : 0;

        // Format the number:
        return negative + (mod ? base.substr(0, mod) + opts.thousand : "") + base.substr(mod).replace(/(\d{3})(?=\d)/g, "$1" + opts.thousand) + (usePrecision ? opts.decimal + toFixed(Math.abs(number), usePrecision).split('.')[1] : "");
    };


    /**
     * Format a number into currency
     *
     * Usage: accounting.formatMoney(number, symbol, precision, thousandsSep, decimalSep, format)
     * defaults: (0, "$", 2, ",", ".", "%s%v")
     *
     * Localise by overriding the symbol, precision, thousand / decimal separators and format
     * Second param can be an object matching `settings.currency` which is the easiest way.
     *
     * To do: tidy up the parameters
     */
    var formatMoney = lib.formatMoney = function(number, symbol, precision, thousand, decimal, format) {
        // Resursively format arrays:
        if (isArray(number)) {
            return map(number, function(val) {
                return formatMoney(val, symbol, precision, thousand, decimal, format);
            });
        }

        // Clean up number:
        number = unformat(number);

        // Build options object from second param (if object) or all params, extending defaults:
        var opts = defaults(
        (isObject(symbol) ? symbol : {
            symbol: symbol,
            precision: precision,
            thousand: thousand,
            decimal: decimal,
            format: format
        }),
        lib.settings.currency),

            // Check format (returns object with pos, neg and zero):
            formats = checkCurrencyFormat(opts.format),

            // Choose which format to use for this value:
            useFormat = number > 0 ? formats.pos : number < 0 ? formats.neg : formats.zero;

        // Return with currency symbol added:
        return useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(number), checkPrecision(opts.precision), opts.thousand, opts.decimal));
    };


    /**
     * Format a list of numbers into an accounting column, padding with whitespace
     * to line up currency symbols, thousand separators and decimals places
     *
     * List should be an array of numbers
     * Second parameter can be an object containing keys that match the params
     *
     * Returns array of accouting-formatted number strings of same length
     *
     * NB: `white-space:pre` CSS rule is required on the list container to prevent
     * browsers from collapsing the whitespace in the output strings.
     */
    lib.formatColumn = function(list, symbol, precision, thousand, decimal, format) {
        if (!list || !isArray(list)) return [];

        // Build options object from second param (if object) or all params, extending defaults:
        var opts = defaults(
        (isObject(symbol) ? symbol : {
            symbol: symbol,
            precision: precision,
            thousand: thousand,
            decimal: decimal,
            format: format
        }),
        lib.settings.currency),

            // Check format (returns object with pos, neg and zero), only need pos for now:
            formats = checkCurrencyFormat(opts.format),

            // Whether to pad at start of string or after currency symbol:
            padAfterSymbol = formats.pos.indexOf("%s") < formats.pos.indexOf("%v") ? true : false,

            // Store value for the length of the longest string in the column:
            maxLength = 0,

            // Format the list according to options, store the length of the longest string:
            formatted = map(list, function(val, i) {
                if (isArray(val)) {
                    // Recursively format columns if list is a multi-dimensional array:
                    return lib.formatColumn(val, opts);
                } else {
                    // Clean up the value
                    val = unformat(val);

                    // Choose which format to use for this value (pos, neg or zero):
                    var useFormat = val > 0 ? formats.pos : val < 0 ? formats.neg : formats.zero,

                        // Format this value, push into formatted list and save the length:
                        fVal = useFormat.replace('%s', opts.symbol).replace('%v', formatNumber(Math.abs(val), checkPrecision(opts.precision), opts.thousand, opts.decimal));

                    if (fVal.length > maxLength) maxLength = fVal.length;
                    return fVal;
                }
            });

        // Pad each number in the list and send back the column of numbers:
        return map(formatted, function(val, i) {
            // Only if this is a string (not a nested array, which would have already been padded):
            if (isString(val) && val.length < maxLength) {
                // Depending on symbol position, pad after symbol or at index 0:
                return padAfterSymbol ? val.replace(opts.symbol, opts.symbol + (new Array(maxLength - val.length + 1).join(" "))) : (new Array(maxLength - val.length + 1).join(" ")) + val;
            }
            return val;
        });
    };


    accounting = lib;

    // Root will be `window` in browser or `global` on the server:
}(this));
const nanoid = function (length = 8) {
  var result           = '';
  var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  var charactersLength = characters.length;
  for ( var i = 0; i < length; i++ ) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
};
var cmd_report_modifiers = {
  from: "@year-start", // inclusive 
  to: "@year-end", // exclusive
};

function report_set_modifiers(args) {
  Object.keys(cmd_report_modifiers).forEach(x => {
    cmd_report_modifiers[x] = args.modifiers[x] || cmd_report_modifiers[x];
  });
}

var CMD_MODIFER_REPLACE = {
  "@year-start": () => new Date(new Date().getFullYear(), 0, 1) / 1000 | 0,
  "@min": () => fs_data_range.length ? (Date.parse(fs_data_range[0] + '-01-01T00:00:00') / 1000 | 0) : 0,
  "@max": () => (fs_data_range.length ? Date.parse((fs_data_range[fs_data_range.length - 1] + 1) + '-01-01T00:00:00') : new Date(new Date().getFullYear() + 1, 0, 1) - 1000) / 1000 | 0,
  "@year-end": () => new Date(new Date().getFullYear() + 1, 0, 1) / 1000 | 0,
  "@month-start": () => new Date(new Date().getFullYear(), new Date().getMonth(), 1) / 1000 | 0,
  "@month-end": () => new Date(new Date().getFullYear(), new Date().getMonth() + 1, 0) / 1000 | 0,
  "@today": () => new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate(), 0, 0, 0, 0) / 1000 | 0,
  "@tomorrow": () => new Date(new Date().getFullYear(), new Date().getMonth(), new Date().getDate() + 1, 0, 0, 0, 0) / 1000 | 0,
};

/*
 * IMPORTANT: callback must be async
 */
async function report_traverse(args, callback, afterOpenCallback) {
  let min_f = fs_data_range.length ? Date.parse(fs_data_range[0] + '-01-01T00:00:00') : 0;
  let f = Date.parse(report_replaceDateStr(cmd_report_modifiers.from) + 'T00:00:00') || min_f;
  let max_t = fs_data_range.length ? Date.parse((fs_data_range[fs_data_range.length - 1] + 1) + '-01-01T00:00:00') : new Date(new Date().getFullYear() + 1, 0, 1) - 1000;
  let t = Date.parse(report_replaceDateStr(cmd_report_modifiers.to) + 'T00:00:00') - 1000 || max_t;
  let range = data_books_required(f, t);
  let ignored = Object.keys(cmd_report_modifiers);
  await data_iterate_books(range, async function (book) {
    let len = book.length;
    WHILE: while (len--) {
      if ((book[len].time >= (f / 1000 | 0)) && (book[len].time < t / 1000 | 0)) {
        for (mod in args.modifiers) {
          if (ignored.indexOf(mod) < 0 && args.modifiers[mod] != book[len][mod]) continue WHILE;
        }
        await callback(book[len]);
      }
    }
  }, afterOpenCallback);
}

async function report_sum_accounts(args, sum_parent) {
  cmd_report_modifiers.from = args.modifiers.from; // unless specified, query everything
  cmd_report_modifiers.to = args.modifiers.to;
  
  let d;
  await report_traverse(args, async function(entry) {
    for (let t of entry.transfers) {
      if (sum_parent) {
        let levels = t[1].split(".");
        let previous = "";
        for (let l of levels) {
          let k = previous + l;
          if (!d[k]) d[k] = new Big(0);
          d[k] = d[k].plus(t[2]);
          previous = k + ".";
        }
      } else {
        d[t[1]] = d[t[1]].plus(t[2]);
      }
    }
  }, async function() { // wait until books are opened to load accounts
    
    d = JSON.parse(JSON.stringify(data.accounts));
    Object.keys(d).forEach(x => d[x] = new Big(0));
  });
  
  Object.keys(d).forEach(x => d[x] = d[x].toNumber());
  return d;
}

function report_replaceDateStr(dateStr) {
  if (CMD_MODIFER_REPLACE[dateStr]) return new Date(CMD_MODIFER_REPLACE[dateStr]() * 1000).toISOString().split('T')[0];
  return dateStr;
}
function isNumberAtIndex(str, i) {
  switch(str[i]) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      return true;
  }
  return false;
}
var fs = typeof require != "undefined" ? require('fs') : {};
var readline = typeof require != "undefined" ? require('readline') : {};

var fs_data_range = [];

async function fs_get_data_range() {
  let match = fs_book_name.match(/^(.*\/)([^/]+)$/);
  match = match ? match[1] : '.';
  let result = [];
  fs.readdirSync(match).forEach(x => {
    let m = x.match(/\.(\d{4})\.ledg$/);
    if (m && m[1]) result.push(parseInt(m[1]));
  });
  return fs_data_range = result.sort();
}

async function fs_read_book(year) {
  let path = fs_book_name + '.' + year + '.ledg';
  data.books[year] = [];
  if (fs.existsSync(path)) {
    let fileStream = fs.createReadStream(path);

    let rl = readline.createInterface({
      input: fileStream,
      crlfDelay: Infinity
    });
    let entry = null;
    for await (let line of rl) {
      if (line[4] == '-' && line[7] == '-') { // start entry
        if (entry) { entry_balance(entry); data.books[year].push(entry); } // commit previous

        entry = {
          time: Math.floor(Date.parse(line.substring(0, 10) + 'T00:00:00') / 1000),
          transfers: []
        };
        
        let hash_index = line.indexOf('#');
        
        let UUIDreassigned = false;
              
        if (line.trim().length <= 11 || hash_index < 0) { // has no hash or has no description
          entry.description = line.substring(11);
          entry.uuid = nanoid(8);
          UUIDreassigned = true;
        } else if (line.length - hash_index < 9) { // has hash but incomplete uuid
          entry.description = line.substring(11, hash_index - 1);
          entry.uuid = nanoid(8);
          UUIDreassigned = true;
        } else {
          entry.description = line.substring(11, line.length - 10);
          entry.uuid = line.substr(line.length - 8, 8);
        }
        
        if (UUIDreassigned) {
          data.booksOpened[year] = DATA_BOOK_DIRTY;
          console.log(`While opening the ${year} book, an entry had incomplete UUID and had been reassigned.`);
        }
      } else if (line[2] == ';') { // entry meta data
        let colonIndex = line.indexOf(':');
        if (colonIndex < 0) { colonIndex = line.length; line += ':""'; }
        entry[line.substring(3, colonIndex)] = JSON.parse(line.substring(colonIndex + 1));
      } else if (line[0] == ' ' && line[1] == ' ') { // transfers
        let t = [];
        let splits = line.substring(2).split('\t');
        if (splits.length >= 2) {
          t[0] = splits[0];
          t[1] = splits[1].trim();
          data.accounts[t[1]] = 1;
          if (splits[2]) splits[2] = splits[2].trim();
          t[2] = splits[2] && splits[2].length ? parseFloat(splits[2]) : 0;
          entry.transfers.push(t);
        }
      }
    }
    if (entry) { entry_balance(entry); data.books[year].push(entry); }
  }
}

async function fs_write_books() {
  for (let y in data.booksOpened) {
    if (data.booksOpened[y] == DATA_BOOK_DIRTY) {
      let path = fs_book_name + '.' + y + '.ledg';
      await new Promise((resolve, reject) => {
        const file = fs.createWriteStream(path);
        for (let i = 0;i < data.books[y].length;i++) {
          file.write(fs_serialize_entry(data.books[y][i]) + "\n");
        }
        file.end();
        file.on("finish", resolve);
        file.on("error", reject);
      });
    }
  }
}

async function fs_write_config() {
  let path = fs_book_name + '.config.ledg';
  // TODO: need to be async later
  fs.writeFileSync(path, JSON.stringify({
    data: { accounts: data.accounts },
    data_acc_imb: data_acc_imb
  }));
}

async function fs_attempt_load_config() {
  let path = fs_book_name + '.config.ledg';
  // TODO: need to be async later
  try {
    let opts = JSON.parse(fs.readFileSync(path));
    Object.assign(data, opts.data);
    data_acc_imb = opts.data_acc_imb || data_acc_imb;
  } catch (e) {}
}

async function fs_construct_config() {
  await data_open_books(await fs_get_data_range());
  await fs_write_config();
}

/* Example:
 *
2021-03-14 Test #UocjnJc1
  ;goose:3.14159
  1	Expense.Taxes.Federal	2000.02
  2	Assets.Checking	-500
  3	Liability.CC	-1449.51
  	Imbalance	-50.51
*/
function fs_serialize_entry(entry) {
  let str = entry_datestr(entry) + ' ' + entry.description.trim() + ' #' + entry.uuid;
  for (let key in entry) {
    if (key == 'description' || key == 'time' || key == 'uuid' || key == 'transfers') continue;
    str += '\n  ;' + key + ':' + JSON.stringify(entry[key]);
  }
  str += '\n';
  for (let t of entry.transfers) {
    str += '  ' + t[0] + '\t' + t[1] + '\t' + t[2] + '\n';
  }
  return str;
}

/*
 * ========================
 * FS runtime variables
 * ========================
 */
var fs_book_name = 'book'; // ex: book.2019.ledg, book.ledg, book.budget.ledg
function argsparser(_args) {
  let args = { _:[], flags: {}, modifiers: {} };
  
  let bypass = false;
  for (let i = 0;i < _args.length;i++) {
    let arg = _args[i];
    
    if (arg == '--') { bypass = true; continue; }
    if (bypass) { args._.push(arg); continue; }
    
    let match;
    if (match = arg.match(/^-([a-zA-Z])(.+)$/)) {
      args.flags[match[1]] = match[2];
    } else if (match = arg.match(/^--?([^=]+)(=(.*))?$/)) {
      let key = match[1];
      if (!isNaN(Number(key))) {
        args._.push(arg);
        continue;
      }
      let val = match[3] || (arg.indexOf('=') > 0 ? '' : true);
      if (!isNaN(Number(val))) val = Number(val);
      if (val == 'true') val = true;
      if (val == 'false') val = false;
      args.flags[key] = val;
    } else if (match = arg.match(/^([a-zA-Z_]+):(.*)$/)) {
      args.modifiers[match[1]] = match[2];
    } else {
      args._.push(arg)
    }
  }
  args._ = args._.filter(x => x.length);
  return args;
}

function print_entry_ascii(entry, maxWidth) {
  maxWidth = maxWidth || print_max_width_from_entries([entry]);
  
  let alignrightwidth = 2 + maxWidth.transDesc + (maxWidth.transDesc ? 2 : 0) + maxWidth.acc + 2 + maxWidth.mon - 9 - 10 - entry.description.length;
  let str = c.cyanBright.bold(entry_datestr(entry)) + ' ' + entry.description.trim() +
            Array(Math.max(alignrightwidth, maxWidth.desc + 2 - entry.description.length)).fill(' ').join('') + c.cyan(' #' + entry.uuid);
  for (let key in entry) {
    if (key == 'description' || key == 'time' || key == 'uuid' || key == 'transfers') continue;
    str += c.green('\n  ;' + key + ':' + JSON.stringify(entry[key]));
  }
  str += '\n';
  for (let t of entry.transfers) {
    let mon = print_format_money(t[2]);
    str += '  ' + 
           (maxWidth.transDesc ? t[0] + Array(maxWidth.transDesc - t[0].length + 2).fill(' ').join('') : '') +
           c.yellowBright(t[1] + Array(maxWidth.acc - t[1].length + 2).fill(' ').join('')) +
           Array(maxWidth.mon - mon.length + 2).fill(' ').join('') + print_color_money(t[2]) + '\n';
  }
  return str;
}

function print_header_style(str) {
  return c.underline(str);
}

function print_alternate_row(row, i) {
  return i % 2 ? `${ESC}[48;5;234m${(row)}${ESC}[49m` : row;
}

function print_pad_right(str, num, len) {
  if ((len || str.length) >= num) return str;
  return str + Array(1 + num - (len || str.length)).join(' ');
}
function print_pad_left(str, num, len) {
  if ((len || str.length) >= num) return str;
  return Array(1 + num - (len || str.length)).join(' ') + str;
}

function print_max_width_from_entries(entries) {
  let a = { transDesc: 0, desc: 0, acc: 0, mon: 0 };
  let len = entries.length;
  while (len--) {
    let e = entries[len];
    a.desc = Math.max(a.desc, e.description.length);
    
    let len2 = e.transfers.length;
    while (len2--) { 
      a.transDesc = Math.max(a.transDesc, e.transfers[len2][0].length);
      a.acc = Math.max(a.acc, e.transfers[len2][1].length);
      a.mon = Math.max(a.mon, print_format_money(e.transfers[len2][2]).length);
    }
  }
  return a;
}

function print_format_money(m) {
  return accounting.formatMoney(m);
}

function print_color_money(m) {
  if (m < 0)
    return c.redBright(print_format_money(m));
  if (m > 0)
    return c.green(print_format_money(m));
  return print_format_money(m);
}
var tree_c0 = "├";
var tree_c1 = "─";
var tree_c2 = "└";
var tree_c3 = "│";

function expand_account(list=Object.keys(data.accounts)) {
  let data = [];
  let tree = {};
  for (let acc of list) {
    let levels = acc.split('.');
    let prnt = tree[levels[0]] || (tree[levels[0]] = {});
    for (let i = 1;i < levels.length;i++) {
      let l = levels[i];
      prnt = prnt[l] = (prnt[l] || {});
    }
  }
  
  _expand_account_subtree("", tree, data);
  return data;
}

function _expand_account_subtree(pre, t, fullList) {
  let keys = Object.keys(t);
  for (let i = 0;i < keys.length;i++) {
    fullList.push(pre + keys[i]);
    _expand_account_subtree(pre + keys[i] + '.', t[keys[i]], fullList);
  }
}

/*
 * takes in a list of accounts
 */
function print_accountTree(list) {
  let tree = {};
  let data = {list: [], fullList: [], maxLength: 0};
  list = list.sort();
  for (let acc of list) {
    let levels = acc.split('.');
    let prnt = tree[levels[0]] || (tree[levels[0]] = {});
    for (let i = 1;i < levels.length;i++) {
      let l = levels[i];
      prnt = prnt[l] = (prnt[l] || {});
    }
  }
  
  _print_accountTree_subtree("", tree, data);
  return data;
}

function _print_accountTree_subtree(pre, t, data, c3_col=[]) {
  let keys = Object.keys(t);
  for (let i = 0;i < keys.length;i++) {
    let prefix = '';
    for (let j = 0;j < c3_col.length;j++) {
      prefix += c3_col[j] ? tree_c3 + '  ' : '   ';
    }
    prefix += (i == keys.length - 1 ? tree_c2 : tree_c0);
    let row = prefix + keys[i];
    data.maxLength = Math.max(data.maxLength, row.length);
    data.list.push(row);
    data.fullList.push(pre + keys[i]);
    _print_accountTree_subtree(pre + keys[i] + '.', t[keys[i]], data, c3_col.concat([i != keys.length - 1]));
  }
}
async function cmd_accounts(args) {
  if (args._[0] == 'add') {
    for (let i = 1;i < args._.length;i++) {
      data.accounts[args._[i]] = 1;
    }
    await fs_write_config();
    console.log('Saved to ' + fs_book_name + '.config.ledg');
    return;
  }
  
  if (args.modifiers.from && args.modifiers.from.length) {
    delete args.modifiers.from;
    cmd_report_modifiers.from = '';
    console.log("Warning: from modifier is ignored in account command\n");
  }
  
  let tree = args._[0] == 'tree';
  
  if (args.flags['sum-parent'] === false && args.flags['max-depth']) {
    args.flags['sum-parent'] = true;
    console.log("Warning: with max-depth, sum-parent is always enabled");
  } else if (args.flags['max-depth'] && !tree) {
    console.log("sum-parent is enabled with max-depth set");
  }
  
  args.flags['max-depth'] = args.flags['max-depth'] || Infinity;
  let countDots = (s) => {let m = s.match(/\./g); return m ? m.length + 1 : 1};
  
  let sumParent = typeof args.flags['sum-parent'] === 'undefined' ? tree : args.flags['sum-parent']; // tree default to sum parent
  
  let balanceData = await report_sum_accounts(args, sumParent);
  let accounts = Object.keys(balanceData);
  
  
  let width = "Accounts".length;
  let width2 = "Balance".length;
  accounts.forEach(x => {
    width2 = Math.max(width2, print_format_money(balanceData[x]).length);
  });
  
  let accs = accounts.sort(); // wait for open book then key
  
  if (tree) {
    if (args.flags['hide-zero'])
      accounts = accounts.filter(x => balanceData[x] != 0);
    let accTree = print_accountTree(accounts);
    
    console.log(`\n${print_header_style(print_pad_right("Accounts", accTree.maxLength))} ${print_header_style(print_pad_right("Balance", width2))}`);
    
    let i = -1;
    accTree.list.forEach((x) => {
      if (args.flags['hide-zero'] && balanceData[x] == 0) return;
      if (countDots(accTree.fullList[++i]) > args.flags['max-depth']) return;
      console.log(print_alternate_row(`${print_pad_right(x, accTree.maxLength)} ${print_pad_left(print_color_money(balanceData[accTree.fullList[i]]), width2, print_format_money(balanceData[accTree.fullList[i]]).length)}`, i));
    });
  } else {
    accs.forEach(x => width = Math.max(width, x.length)); 
  
  
    console.log(`\n${print_header_style(print_pad_right("Accounts", width))} ${print_header_style(print_pad_right("Balance", width2))}`);
    let i = 0;
    accs.forEach((x) => {
      if (args.flags['hide-zero'] && balanceData[x] == 0) return;
      if (countDots(x) > args.flags['max-depth']) return;
      console.log(print_alternate_row(`${print_pad_right(x, width)} ${print_pad_left(print_color_money(balanceData[x]), width2, print_format_money(balanceData[x]).length)}`, i++));
    });
    console.log("");
  }
}
 
async function cmd_info(args) {
  if (Object.keys(args.modifiers).length == 0) {
    args.modifiers.from = '@month-start';
    args.modifiers.to = '@max';
    console.log(`No modifiers, using from:@month-start and to:@max\n`);
  } else {
    args.modifiers.from = args.modifiers.from || '@min';
    args.modifiers.to = args.modifiers.to || '@max';
  }
  
  report_set_modifiers(args);
  
  let entries = [];
  await report_traverse(args, async function(entry) {
    entries.push(entry);
  });
  entries = entries.sort((a, b) => a.time - b.time);
  let maxWidth = print_max_width_from_entries(entries);
  for (let e of entries) {    
    console.log(print_entry_ascii(e, maxWidth));
  }
}
async function cmd_version() {
  console.log(c.bold('ledg 0.1') + ' built for cli');
}
async function cmd_add(args) {
  let desc = [];
  let transfers = [];
  let currentTransfer = null;

  let opts = JSON.parse(JSON.stringify(args.modifiers));
  
  delete opts.uuid;
  delete opts.time;
  delete opts.from;
  delete opts.to;
  delete opts.description;
  
  args.flags.date = args.flags.date || args.flags.D;
  
  opts.time = ((args.flags.date ? (Date.parse(report_replaceDateStr(args.flags.date) + 'T00:00:00') || new Date().getTime()) : new Date().getTime()) / 1000) | 0;
  
  Object.keys(opts).forEach(k => {
    let n = Number(opts[k]);
    if (!isNaN(n)) opts[k] = n;
  });

  let _ = args._;

  for (let i = 0;i < _.length;i++) {
    let v = _[i].trim().replace(/ /g, '');
    let num = Number(v);
    
    if (v.match(/^\d{4}-\d{2}-\d{2}$/)) {
      opts.time = ((Date.parse(report_replaceDateStr(v) + 'T00:00:00') / 1000) | 0) || opts.time;
    } else if (!isNaN(num)) {
      if (currentTransfer) {
        currentTransfer[2] = num;
        transfers.push(currentTransfer);
        currentTransfer = null;
      } else // entry description
        desc.push(_[i].trim());
    } else if (isArgAccount(v)) { // start account with category
      if (currentTransfer) { // start new one, commit old
        transfers.push(currentTransfer);
        currentTransfer = null;
        continue;
      }
      let accs = fzy_query_account(v, expand_account());
      currentTransfer = ['', null, 0];
      if (accs.length == 0) {
        process.stdout.write(`"${c.bold(v.replace(/\$/g, '').replace(/\!/g, ''))}" does not match anything. Create it? `);
        let ans = args.flags.y ? 'y' : (await readline_prompt()).toLowerCase();
        if (args.flags.y) console.log('y');
        if (ans == 'y' || ans == 'yes') {
          currentTransfer[1] = v.replace(/\$/g, '').replace(/\!/g, '');
        } else {
          console.log('Abort.');
          return 1;
        }
      } else if (accs.length == 1) {
        currentTransfer[1] = accs[0];
      } else {
        console.log(`Multiple accounts matched for: ${c.bold(v)}\n`);
        for (let j = 0;j < accs.length;j++) {
          console.log(`${j + 1} ${accs[j]}`);
        }
        process.stdout.write('\nChoose one: ');
        let ans = Math.max(Math.min(parseInt((await readline_prompt())) || 1, accs.length), 0) - 1;
        console.log(`${ESC}[1AChoose one: ${c.green(accs[ans])}`);
        currentTransfer[1] = accs[ans];
      }
    }  else {
      if (currentTransfer) // transfer description
        currentTransfer[0] = (currentTransfer[0] + ' ' + _[i].trim()).trim();
      else // entry description
        desc.push(_[i].trim());
    }
  }
  if (currentTransfer) transfers.push(currentTransfer);

  let entry = entry_create(desc.join(" "), transfers, opts);
  console.log("\n" + print_entry_ascii(entry));
  
  // empty
  if (entry.transfers.length == 0) {
    console.log('Empty entry, abort.');
    return 1;
  }
  
  // handle imbalance
  if (entry.transfers.filter(x => x[1] == data_acc_imb).length) {
    process.stdout.write(`Entry is imbalanced, continue? `);
    let ans = args.flags.y ? 'y' : (await readline_prompt()).toLowerCase();
    if (args.flags.y) console.log('y');
    if (ans != 'y' && ans != 'yes') {
      console.log('Abort.');
      return 1;
    }
  }
  await data_push_entry(entry);
  await fs_write_config();
  console.log('Entry added.');
}
// from github ansi-colors
// with slight modifications
const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
const identity = val => val;

/* eslint-disable no-control-regex */
// this is a modified version of https://github.com/chalk/ansi-regex (MIT License)
const ANSI_REGEX = /[\u001b\u009b][[\]#;?()]*(?:(?:(?:[^\W_]*;?[^\W_]*)\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;

const create_color = () => {
  const colors = { enabled: true, visible: true, styles: {}, keys: {} };

  // if ('FORCE_COLOR' in process.env) {
  //   colors.enabled = process.env.FORCE_COLOR !== '0';
  // }

  const ansi = style => {
    let open = style.open = `\u001b[${style.codes[0]}m`;
    let close = style.close = `\u001b[${style.codes[1]}m`;
    let regex = style.regex = new RegExp(`\\u001b\\[${style.codes[1]}m`, 'g');
    style.wrap = (input, newline) => {
      if (input.includes(close)) input = input.replace(regex, close + open);
      let output = open + input + close;
      // see https://github.com/chalk/chalk/pull/92, thanks to the
      // chalk contributors for this fix. However, we've confirmed that
      // this issue is also present in Windows terminals
      return newline ? output.replace(/\r*\n/g, `${close}$&${open}`) : output;
    };
    return style;
  };

  const wrap = (style, input, newline) => {
    return typeof style === 'function' ? style(input) : style.wrap(input, newline);
  };

  const style = (input, stack) => {
    if (input === '' || input == null) return '';
    if (colors.enabled === false) return input;
    if (colors.visible === false) return '';
    let str = '' + input;
    let nl = str.includes('\n');
    let n = stack.length;
    if (n > 0 && stack.includes('unstyle')) {
      stack = [...new Set(['unstyle', ...stack])].reverse();
    }
    while (n-- > 0) str = wrap(colors.styles[stack[n]], str, nl);
    return str;
  };

  const define = (name, codes, type) => {
    colors.styles[name] = ansi({ name, codes });
    let keys = colors.keys[type] || (colors.keys[type] = []);
    keys.push(name);

    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set(value) {
        colors.alias(name, value);
      },
      get() {
        let color = input => style(input, color.stack);
        Reflect.setPrototypeOf(color, colors);
        color.stack = this.stack ? this.stack.concat(name) : [name];
        return color;
      }
    });
  };

  define('reset', [0, 0], 'modifier');
  define('bold', [1, 22], 'modifier');
  define('dim', [2, 22], 'modifier');
  define('italic', [3, 23], 'modifier');
  define('underline', [4, 24], 'modifier');
  define('inverse', [7, 27], 'modifier');
  define('hidden', [8, 28], 'modifier');
  define('strikethrough', [9, 29], 'modifier');

  define('black', [30, 39], 'color');
  define('red', [31, 39], 'color');
  define('green', [32, 39], 'color');
  define('yellow', [33, 39], 'color');
  define('blue', [34, 39], 'color');
  define('magenta', [35, 39], 'color');
  define('cyan', [36, 39], 'color');
  define('white', [37, 39], 'color');
  define('gray', [90, 39], 'color');
  define('grey', [90, 39], 'color');

  define('bgBlack', [40, 49], 'bg');
  define('bgRed', [41, 49], 'bg');
  define('bgGreen', [42, 49], 'bg');
  define('bgYellow', [43, 49], 'bg');
  define('bgBlue', [44, 49], 'bg');
  define('bgMagenta', [45, 49], 'bg');
  define('bgCyan', [46, 49], 'bg');
  define('bgWhite', [47, 49], 'bg');

  define('blackBright', [90, 39], 'bright');
  define('redBright', [91, 39], 'bright');
  define('greenBright', [92, 39], 'bright');
  define('yellowBright', [93, 39], 'bright');
  define('blueBright', [94, 39], 'bright');
  define('magentaBright', [95, 39], 'bright');
  define('cyanBright', [96, 39], 'bright');
  define('whiteBright', [97, 39], 'bright');

  define('bgBlackBright', [100, 49], 'bgBright');
  define('bgRedBright', [101, 49], 'bgBright');
  define('bgGreenBright', [102, 49], 'bgBright');
  define('bgYellowBright', [103, 49], 'bgBright');
  define('bgBlueBright', [104, 49], 'bgBright');
  define('bgMagentaBright', [105, 49], 'bgBright');
  define('bgCyanBright', [106, 49], 'bgBright');
  define('bgWhiteBright', [107, 49], 'bgBright');

  colors.ansiRegex = ANSI_REGEX;
  colors.hasColor = colors.hasAnsi = str => {
    colors.ansiRegex.lastIndex = 0;
    return typeof str === 'string' && str !== '' && colors.ansiRegex.test(str);
  };

  colors.alias = (name, color) => {
    let fn = typeof color === 'string' ? colors[color] : color;

    if (typeof fn !== 'function') {
      throw new TypeError('Expected alias to be the name of an existing color (string) or a function');
    }

    if (!fn.stack) {
      Reflect.defineProperty(fn, 'name', { value: name });
      colors.styles[name] = fn;
      fn.stack = [name];
    }

    Reflect.defineProperty(colors, name, {
      configurable: true,
      enumerable: true,
      set(value) {
        colors.alias(name, value);
      },
      get() {
        let color = input => style(input, color.stack);
        Reflect.setPrototypeOf(color, colors);
        color.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;
        return color;
      }
    });
  };

  colors.theme = custom => {
    if (!isObject(custom)) throw new TypeError('Expected theme to be an object');
    for (let name of Object.keys(custom)) {
      colors.alias(name, custom[name]);
    }
    return colors;
  };

  colors.alias('unstyle', str => {
    if (typeof str === 'string' && str !== '') {
      colors.ansiRegex.lastIndex = 0;
      return str.replace(colors.ansiRegex, '');
    }
    return '';
  });

  colors.alias('noop', str => str);
  colors.none = colors.clear = colors.noop;

  colors.stripColor = colors.unstyle;
  // colors.symbols = require('./symbols');
  colors.define = define;
  return colors;
};

var c = create_color();
var CMD_LIST = {
  'version': cmd_version,
  'add': cmd_add,
  'info': cmd_info,
  'accounts': cmd_accounts
};
const DEFAULT_COMMAND = 'version';

async function index() {
  fs_book_name = process.env["LEDG_BOOK"] || fs_book_name;
  let argv = process.argv;
  if (fs.existsSync(`${process.env.HOME}/.ledgrc`)) {
    let content = fs.readFileSync(`${process.env.HOME}/.ledgrc`).toString();
    argv = content.replace(/\r/g, '').split("\n").concat(argv.slice(2));
  }
  
  var args = argsparser(argv);
  fs_book_name = args.flags.F || args.flags.file || fs_book_name;
  
  await fs_get_data_range();
  if (fs.existsSync(fs_book_name + '.config.ledg'))
    await fs_attempt_load_config();
  else if (fs_data_range.length) {
    console.log("Missing config file, reconstructing from existing books");
    await fs_construct_config();
  }

  report_set_modifiers(args);
  let cmd;
  
  if (args._[0]) {
    let matches = Object.keys(CMD_LIST).filter(x => x.indexOf(args._[0]) == 0).sort();
    if (matches.length == 0) { }
    else if (matches.length == 1) cmd = CMD_LIST[matches[0]];
    else {
      console.log(`Ambiguous action command ${c.bold(args._[0])}, multiple matches availabe: ${matches.map(x => c.bold(x)).join(", ")}`);
      process.exit(1);
    }
  }
  
  if (cmd) {
    args._.splice(0,1);
    let c = await cmd(args);
    if (c) { process.exit(c) }
    else { await fs_write_books(); }
  }
}

var readline_last_value;

async function readline_prompt(muted) {
  stdin_rl.resume();
  const line1 = (await stdin_it.next()).value;
  readline_last_value = line1;
  stdin_rl.pause();
  return line1.trim();
}

var stdin_rl;
var stdin_it;
var ESC = '';

if (require.main === module && typeof TEST == "undefined") {
  stdin_rl = readline.createInterface({
    input: process.stdin, //or fileStream
    output: process.stdout
  });
  stdin_it = stdin_rl[Symbol.asyncIterator]();
  stdin_rl.pause();
  index();
} else {
    // console.log('required as a module');
}
